# PIMAX- Ant crawling motion

from cProfile import label
from fnmatch import translate
from hmac import trans_36
import numpy as np
from cmath import sqrt
import pygame.camera
import pymunk,pymunk.pygame_util
import pygame,pygame.image
import sys
import matplotlib.pyplot as plt
from pygame.locals import USEREVENT, QUIT, KEYDOWN, KEYUP, K_s, K_r, K_q, K_ESCAPE, K_UP, K_DOWN

import argparse
from audioop import avg
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

x_ = 0
line = 0

def main(sx=1200,sy=650):
    

    global x_, line
    ndim_s = 2
    ndim_m = 1

    
    # brain
    x = np.zeros((ndim_s, 1))
    xPred = np.zeros_like(x)
    xError = np.zeros_like(x)
    y = np.zeros((ndim_m, 1))

    A = np.zeros([ndim_s, ndim_m])
    b = np.zeros_like(x)

    C1 = np.random.uniform(0.002,0.005)
    C2 = np.random.uniform(-0.05,-0.01)

    C = np.array([[C1 ,C2]])
    h = np.random.uniform(0.0025, 0.0075, size=y.shape) # ones_like(y) * 0.1


    # print(b)
    epsA = 0.15
    epsC = 0.35

    
    def addfloor(space,y=0,e=0):
        floor = pymunk.Segment(space.static_body,(-100,sy-y),(sx+100,sy-y),y)
        floor.elasticity = 0
        floor.friction = 1
        space.add(floor)
        
    def addSpring(space,m0=1,m1=1,m2=1,length=50,stiffness=500,damping=60,
            x0=100,y0=600,size=5,e=0.9):

        global b0
        global b1
        global b2 

        global link0
        global link1
        global link2

        b0 = pymunk.Body(mass=m0,moment=1e99)
        b0.position = (x0,y0)
        
        c0 = pymunk.Poly.create_box(b0, (0.1*size*m0, size))
        c0.elasticity = e
        c0.friction= 1
        b1 = pymunk.Body(mass=m1,moment=1e99)
        b1.position = (100,500)
        c1 = pymunk.Poly.create_box(b1, (0.1*size*m1, size))
        c1.elasticity = e
        c1.friction = 1

        b2 = pymunk.Body(mass=m2,moment=1e99)
        b2.position = (200,600)
        c2 = pymunk.Poly.create_box(b2, (0.1*size*m1, size))
        c2.elasticity = e
        c2.friction= 1

        link0 = pymunk.DampedSpring(a=b0, b=b1,
            anchor_a=(0,0), anchor_b=(0,0),
            rest_length=100, stiffness=stiffness, damping=damping)
   
        
        link1 = pymunk.DampedSpring(a=b0, b=b2,
            anchor_a=(0,0), anchor_b=(0,0),
            rest_length=100, stiffness=stiffness, damping=damping)

        link2 = pymunk.DampedSpring(a=b1, b=b2,
            anchor_a=(0,0), anchor_b=(0,0),
            rest_length=141.1, stiffness=stiffness, damping=damping)

        
        space.add(b0, c0, b1, c1, b2, c2, link0, link1, link2 )
        

    def translate(value, leftMin, leftMax, rightMin, rightMax):
        leftSpan = leftMax - leftMin
        rightSpan = rightMax - rightMin
        valueScaled = float(value - leftMin) / float(leftSpan)
        return rightMin + (valueScaled * rightSpan)

    def changelen(y):

        op=translate(y,-1,1,90,110)
        link0.rest_length = op
        link1.rest_length = op


    space = pymunk.Space()
    space.gravity = 0,981
    addfloor(space,y=25)
    addSpring(space)

    pygame.init()
    screen = pygame.display.set_mode((sx,sy))
    pygame.display.set_caption('Spring Mass Damper')
    clock = pygame.time.Clock()
    font = pygame.font.Font("freesansbold.ttf", 20)
    text = font.render('Closed-Loop Actuation of SMD system (actuating link b0b1): k = 300, d = 30 ', True, "black", "white")
    textRect = text.get_rect()
    textRect.center = (700, 100)
    draw_options = pymunk.pygame_util.DrawOptions(screen)

    i = 0
    timeline = []
    len_b0b1 = []
    len_b1b2 = []
    len_b2b0 = []

    x_values_list = []
    x_error = []
    x_pred = []

    init_b0_pos = 0
    fin_b0_pos = 0

    y_values=[]
    C_values=[]
    A_values=[]
    b0pos = []

    count = 0
    d = 0

    d=[]
    h_values=[]
    b_values=[]
    while True:

        timeline.append(i)

        if i <20 and 1>0 :
            x[0][0] = np.random.uniform(10,15)
            x[1][0] = np.random.uniform(-0.009,0)
        else:

            noisepercent = np.random.uniform(-0.5,0.5)
        
            x[0][0] = (b0._get_velocity()[0])
            x[1][0] = (b0._get_velocity()[1])


        xError = x - xPred
    
        x_values_list.append([x][0][0][0])
        x_error.append([xError][0][0][0])
        x_pred.append([xPred][0][0][0])

        # Train Model
        dA = epsA * xError * y 
        A += dA
        db = epsA * xError 
        b += db

        # Train Controller
        z = np.dot(C, x) + h
        g_z = 1 - np.power(np.tanh(z),2)
        eta = np.dot(A.T, xError) * g_z 

        dC = epsC * np.dot(eta , x.T) 
        dh = epsC * eta 

        C += dC
        h += dh

        # Controler
        y = np.tanh(np.dot(C, x) + h)

        y_values.append(y[0][0])
        A_values.append(A[0][0])
        C_values.append(C[0][0])
        h_values.append(h[0][0])
        b_values.append(np.reshape(b[0][0],(1,1)))

        # Feed forward model
        # predict next sensor state
        xPred = np.dot(A, y) + b

        # add +-0.5% random noise
        noisepercent = np.random.uniform(-0.5,0.5)
        xPred= xPred*(1+noisepercent)
        
        changelen(np.reshape(y[0][0],(1,1)))


        if(i == 1):
            init_b0_pos = b0._get_position()
        if(i>1):
            fin_b0_pos = b0._get_position()
            d.append(init_b0_pos.get_distance(fin_b0_pos))

        len_b0b1.append(b0._get_position().get_distance(b1._get_position()))
        len_b1b2.append(b2._get_position().get_distance(b1._get_position()))
        len_b2b0.append(b0._get_position().get_distance(b2._get_position()))
        b0pos.append(b0._get_position())

        
        
        for event in pygame.event.get():
            

            if event.type==pygame.QUIT or (event.type==pygame.KEYDOWN and 
                    event.key==pygame.K_ESCAPE):

                # print("distance travelled:   ", init_b0_pos.get_distance(fin_b0_pos))             

                # plt.figure(32)
                # plt.plot(timeline, len_b0b1, label = "link b0b1") 
                # plt.plot(timeline, len_b1b2, label = "link b1b2")
                # plt.plot(timeline, len_b2b0, label = "link b2b0")
                # plt.xlabel('time')
                # plt.ylabel('Resting length of links')
                # plt.title('Resting length of links vs time')
                # plt.legend()
                # plt.show()
              
                
                # plt.figure(2)
                # plt.plot(timeline, x_values_list , label = "x")
                # plt.plot(timeline, x_pred, label = "x Pred")
                # plt.plot(timeline,x_error, label = "x Error")
                # plt.xlabel('time')
                # plt.ylabel('x')
                # plt.title('x vs time')
                # plt.legend()
                # plt.show()
                

                # fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True,sharey=True)
                # ax1.plot(timeline, x_values_list , label = "X Actual",linewidth=1,color='orange')
                # ax1.legend(loc='upper right')
                # ax2.plot(timeline,x_pred, label='X Predicted',linewidth=1)
                # ax2.legend(loc='upper right')
                # ax3.plot(timeline,x_error, label='X Error',linewidth=1,color='g')
                # ax3.legend(loc = 'upper right')
                # ax3.set_xlabel("Timeline")
                # ax1.set_ylabel("X Actual")
                # ax2.set_ylabel("X Predicted")
                # ax3.set_ylabel("X Error")
                # plt.legend()
                # plt.legend()
                # plt.show()

                sys.exit(0)
      

        screen.fill(("white"))
        screen.blit(text, textRect)
        space.debug_draw(draw_options)
        space.step(1/60.)
        pygame.display.flip()
        clock.tick(60 if i else 1)
        # pygame.image.save(screen, f'tmp/a{i:05d}.jpg')
        i += 1

if __name__=='__main__':
    main()
#    ffmpeg -i tmp/a%05d.jpg tmp.mp4 && del tmp\*.jpg

# https://wifi.sky.com/login?flowSessionId=63287acac3141f199153e309